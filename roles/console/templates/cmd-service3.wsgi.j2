import zmq
import os.path
import time
import urllib.request, urllib.error, urllib.parse
import crypt
import spwd
import grp
import uuid
import base64
import nacl.utils
from nacl.public import PrivateKey, PublicKey, Box
from nacl.encoding import Base64Encoder

#cmdsrv_pid_file = "{{ cmdsrv_pid_file }}"
#cmdsrv_ready_file = "{{ cmdsrv_ready_file }}"
#iiab-cmd-service = " {{ iiab_cmd_service_url }}"

cmdsrv_pid_file = "/run/iiab-cmdsrv.pid"
cmdsrv_ready_file = "/run/iiab-cmdsrv-ready"
iiab_cmd_service = '/iiab-cmd-service'

server_key_pair = None
server_public_key64 = None # ? not needed
server_public_key_bytes = None

valid_nonces = []
valid_tokens = [] # could add expiry, ip addr

# init() at bottom

alert_param = ',"Alert": "True"}' # global for cmd response

def application(environ, start_response):
    req_method = environ['REQUEST_METHOD']
    req_uri = environ['REQUEST_URI'].split('?')[0] # remove any cache buster
    #print(req_method, req_uri)

    if req_method == 'GET':
        if req_uri == iiab_cmd_service + '/auth/login':
            response_headers = [('Content-type', 'text/plain'), ('Access-Control-Allow-Headers', '*')]
            token = None
            print(environ)
            if 'HTTP_X_IIAB_CREDENTIALS' in environ:
                credentials = environ['HTTP_X_IIAB_CREDENTIALS']
                valid, status = auth_login(credentials)
                if valid:
                    token = str(uuid.uuid1()) # or os.urandom(32) which is bytes and not decodable
            else:
                status = '403 Invalid Login'
            start_response(status, response_headers)
            return token

        else: # these are all gets
            response_headers = [('Content-type', 'text/plain')]
            #print(response_headers)
            status = '200 OK'
            start_response(status, response_headers)

            if req_uri == iiab_cmd_service + '/auth/get_pubkey':
                print('pubkey')
                print(server_public_key64)
                #return server_public_key64
                return server_public_key_bytes
            elif req_uri == iiab_cmd_service + '/auth/get_nonce':
                nonce = nacl.utils.random(Box.NONCE_SIZE)
                print('nonce')
                print (nonce)
                n64 = base64.b64encode(nonce)
                print(n64)
                #return nonce.hex()
                return n64
            elif req_uri == iiab_cmd_service + '/auth/refresh':    # reload passwd cache. not for now as will use token
                print('refresh')
                return ''
            else:
                response_body = dump(environ)
                # convert string response back to bytes
                return [response_body.encode()]

    elif req_method == 'POST':
        if req_uri == iiab_cmd_service + '/cmd':
            response_body = handle_cmd(req_uri, environ)
            status = '200 OK'
            response_headers = [('Content-type', 'application/json'), ('Content-Length', str(len(response_body)))]
            start_response(status, response_headers)
            # convert string response back to bytes
            return [response_body.encode()]

def auth_login(credentials): # candidate for adm_lib
    u_pw = credentials.split(':')
    user = u_pw[0]
    if len(u_pw) == 2:
        password = u_pw[1]
    else:
        status = '403 Invalid Login'
        return False, status

    # see if user exists
    try:
        spwddb = spwd.getspnam(user)
    except:
        status = '403 Invalid Login'
        return False, status

    # must be in sudo group
    grp = grp.getgrnam('sudo')
    if user not in grp.gr_mem:
        status = '403 Invalid Login'
        return False, status

    # check password - N.B. allows password guessing
    readpasswd = spwddb[1]
    pwparts = readpasswd.split('$')
    salt = '$' + pwparts[1] + '$' +  pwparts[2] +'$'
    calcpasswd = crypt.crypt(password, salt)

    if calcpasswd != readpasswd:
        status = '403 Invalid Login'
        return False, status
    else:
        status = '200 OK'
        return True, status

def handle_cmd(req_uri, environ):

    print("in cmd-serve.wsgi")
    start_ms = time.time()

    try:
        request_body_size = int(environ.get('CONTENT_LENGTH', 0))
    except (ValueError):
        request_body_size = 0

    request_body = environ['wsgi.input'].read(request_body_size).decode('utf8')
    # request_body holds command=<text of cmd>
    # it is byte so we convert to string for easier manipulation

    if os.path.exists(cmdsrv_pid_file):
        if os.path.exists(cmdsrv_ready_file):
            # unpack cmd, urldecode, and substitute space for %20
            print(request_body)
            #print(type(request_body))
            cmd = urllib.parse.unquote(request_body.split('=')[1])
            cmd = cmd.replace('%20', ' ')

            response_body = send_command(cmd, start_ms)
        else:
            response_body = '{"Error": "CMDSRV has started but is not ready."' + alert_param
    else:
        response_body = '{"Error": "CMDSRV is not running."' + alert_param

    return response_body

def dump(environ):
    #print("in dump")
    response_body = ['%s: %s' % (key, value) for key, value in sorted(environ.items())]
    response_body = '\n'.join(response_body)
    return response_body

def send_command(cmd, start_ms):

    REQUEST_TIMEOUT = 30000
    send_msg = cmd

    ipc_sock = "/run/cmdsrv_sock"

    try:
        context = zmq.Context()
        #print "Connecting to server..."
        socket = context.socket(zmq.DEALER)
        socket.connect ("ipc://%s" % ipc_sock)
        try:
            # socket.setsockopt(zmq.SOCKOPT_LINGER, 0) this should be the default for close() and is not in python binding
            poll = zmq.Poller()
            poll.register(socket, zmq.POLLIN)

            socket.send_string (send_msg)
            socks = dict(poll.poll(REQUEST_TIMEOUT))

            if socket in socks and socks[socket] == zmq.POLLIN:
                reply_msg = socket.recv_string()
                if '"Error":' not in reply_msg:
                    cur_ms = time.time()
                    elapsed_ms = cur_ms - start_ms
                    reply_msg = '{"Data": ' + reply_msg + ',"Resp_time": "' + str(elapsed_ms) + '"}'
            else:
                reply_msg = '{"Error": "No Response from CMDSRV in ' + str(REQUEST_TIMEOUT) + ' milliseconds"' + alert_param

            socket.setsockopt(zmq.LINGER, 0)
        finally:
            socket.close()
            try:
                poll.unregister(socket)
            except Exception:
                pass

    except Exception as e:
        reply_msg = '{"Error": "' + str(e) + '"' + alert_param

    return reply_msg

def calc_keys():
    global server_key_pair
    global server_public_key64
    global server_public_key_bytes
    server_key_pair = PrivateKey.generate() # nacl
    public_key = server_key_pair.public_key # nacl
    server_public_key_bytes = public_key.encode(Base64Encoder) # nacl
    server_public_key64 = server_public_key_bytes.decode()
    print(server_public_key64)
    print('keys generated')

def init():
    calc_keys()

init()
