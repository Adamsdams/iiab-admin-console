import zmq
import os.path
import time
import urllib.request, urllib.error, urllib.parse
import nacl.utils
from nacl.public import PrivateKey, Box
from nacl.encoding import Base64Encoder

#cmdsrv_pid_file = "{{ cmdsrv_pid_file }}"
#cmdsrv_ready_file = "{{ cmdsrv_ready_file }}"
#iiab-cmd-service = " {{ iiab_cmd_service_url }}"

cmdsrv_pid_file = "/run/iiab-cmdsrv.pid"
cmdsrv_ready_file = "/run/iiab-cmdsrv-ready"
iiab_cmd_service = '/iiab-cmd-service'

server_key_pair = None
server_public_key64 = 'why is this not set' # use the next one
public_key_bytes = None

nonces = []

# init() at bottom

alert_param = ',"Alert": "True"}'

def application(environ, start_response):
    req_method = environ['REQUEST_METHOD']
    req_uri = environ['REQUEST_URI'].split('?')[0] # remove any cache buster
    print(req_method, req_uri)

    if req_method == 'GET':
        response_headers = [('Content-type', 'text/plain')]
        #print(response_headers)
        status = '200 OK'
        start_response(status, response_headers)

        if req_uri == iiab_cmd_service + '/auth/get_pubkey':
            print('pubkey')
            print(server_public_key64)
            #return server_public_key64
            return public_key_bytes
        elif req_uri == iiab_cmd_service + '/auth/get_nonce':
            nonce = nacl.utils.random(Box.NONCE_SIZE)
            print('nonce')
            return nonce
        elif req_uri == iiab_cmd_service + '/auth/refresh':    # reload passwd cache
            print('refresh')
            return ''
        else:
            response_body = dump(environ)
            # convert string response back to bytes
            return [response_body.encode()]

    elif req_method == 'POST':
        if req_uri == iiab_cmd_service + '/cmd':
            response_body = handle_cmd(req_uri, environ)
            status = '200 OK'
            response_headers = [('Content-type', 'application/json'), ('Content-Length', str(len(response_body)))]
            start_response(status, response_headers)
            # convert string response back to bytes
            return [response_body.encode()]

def handle_cmd(req_uri, environ):

    print("in cmd-serve.wsgi")
    start_ms = time.time()

    try:
        request_body_size = int(environ.get('CONTENT_LENGTH', 0))
    except (ValueError):
        request_body_size = 0

    request_body = environ['wsgi.input'].read(request_body_size).decode('utf8')
    # request_body holds command=<text of cmd>
    # it is byte so we convert to string for easier manipulation

    if os.path.exists(cmdsrv_pid_file):
        if os.path.exists(cmdsrv_ready_file):
            # unpack cmd, urldecode, and substitute space for %20
            print(request_body)
            #print(type(request_body))
            cmd = urllib.parse.unquote(request_body.split('=')[1])
            cmd = cmd.replace('%20', ' ')

            response_body = send_command(cmd, start_ms)
        else:
            response_body = '{"Error": "CMDSRV has started but is not ready."' + alert_param
    else:
        response_body = '{"Error": "CMDSRV is not running."' + alert_param

    return response_body

def dump(environ):
    #print("in dump")
    response_body = ['%s: %s' % (key, value) for key, value in sorted(environ.items())]
    response_body = '\n'.join(response_body)
    return response_body

def send_command(cmd, start_ms):

    REQUEST_TIMEOUT = 30000
    send_msg = cmd

    ipc_sock = "/run/cmdsrv_sock"

    try:
        context = zmq.Context()
        #print "Connecting to server..."
        socket = context.socket(zmq.DEALER)
        socket.connect ("ipc://%s" % ipc_sock)
        try:
            # socket.setsockopt(zmq.SOCKOPT_LINGER, 0) this should be the default for close() and is not in python binding
            poll = zmq.Poller()
            poll.register(socket, zmq.POLLIN)

            socket.send_string (send_msg)
            socks = dict(poll.poll(REQUEST_TIMEOUT))

            if socket in socks and socks[socket] == zmq.POLLIN:
                reply_msg = socket.recv_string()
                if '"Error":' not in reply_msg:
                    cur_ms = time.time()
                    elapsed_ms = cur_ms - start_ms
                    reply_msg = '{"Data": ' + reply_msg + ',"Resp_time": "' + str(elapsed_ms) + '"}'
            else:
                reply_msg = '{"Error": "No Response from CMDSRV in ' + str(REQUEST_TIMEOUT) + ' milliseconds"' + alert_param

            socket.setsockopt(zmq.LINGER, 0)
        finally:
            socket.close()
            try:
                poll.unregister(socket)
            except Exception:
                pass

    except Exception as e:
        reply_msg = '{"Error": "' + str(e) + '"' + alert_param

    return reply_msg

def calc_keys():
    global server_key_pair
    global server_public_key64
    global public_key_bytes
    server_key_pair = PrivateKey.generate() # nacl
    public_key = server_key_pair.public_key # nacl
    public_key_bytes = public_key.encode(Base64Encoder) # nacl
    server_public_key64 = public_key_bytes.decode()
    print(server_public_key64)
    print('keys generated')

def init():
    calc_keys()

init()
